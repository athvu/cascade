use crate::ast::{Policy, Declaration, Expression, Statement, TypeDecl, FuncDecl, Argument, Annotation, Annotations, Virtualable, FuncCall, DeclaredArgument};

grammar;

// http://lalrpop.github.io/lalrpop/tutorial/006_macros.html
Comma<T>: Vec<T> = {
	<mut v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			v.push(e);
			v
		}
	}
};

pub Policy: Box<Policy> = {
	Expr+ => Box::new(Policy::new(<>)),
}

pub Expr: Expression = {
	<a:Ann> <mut e:Expr> => {
		e.add_annotation(a);
		e
	},
	<BaseExpr>
}

BaseExpr: Expression = {
	// TODO: other keywords beside virtual?
	<v: "virtual"?> <mut d: Decl> => {
		if v.is_some() {
			d.set_virtual();
		}
		Expression::Decl(d)
	},
	Stmt => Expression::Stmt(<>),
};

Decl: Declaration = {
	TypeDecl => Declaration::Type(<>),
	FuncDecl => Declaration::Func(<>),
}

TypeDecl: Box<TypeDecl> = {
	<dr:BuiltInType> <n:Symbol> <i:InheritList?> "{" <mut v:Expr*> "}" => {
		let inherits = match i {
			None => vec![dr.to_string()],
			Some(mut i) => {
				i.push(dr.to_string());
				i
			}
		};
		v.iter_mut().for_each(|e| e.set_class_name_if_decl(n.clone()));
		Box::new(TypeDecl::new(n, inherits, v))
	},
}

InheritList: Vec<String> = {
	"inherits" <Comma<Symbol>>,
}

BuiltInType: String = {
	"domain" => <>.to_string(),
	"resource" => <>.to_string(),
}

FuncDecl: Box<FuncDecl> = {
	"fn" <n: Symbol> "(" <a: Comma<FuncDeclArg>> ")" "{" <b: Stmt+> "}" => Box::new(FuncDecl { class_name: None, name: n, args: a, body: b, annotations: Annotations::new() }),
}

FuncDeclArg: DeclaredArgument = {
	<t: BuiltInType> <n: Symbol> => DeclaredArgument { param_type: t, is_list_param: false, name: n },
	<t: Symbol> <n: Symbol> => DeclaredArgument { param_type: t, is_list_param: false, name: n },
	"[" <t: BuiltInType> "]" <n: Symbol> => DeclaredArgument { param_type: t, is_list_param: true, name: n },
	"[" <t: Symbol> "]" <n: Symbol> => DeclaredArgument { param_type: t, is_list_param: true, name: n },
}

Stmt: Statement = {
	<c:Symbol> "." <n:Symbol> "(" <a:Comma<Arg>> ")" ";" => Statement::Call(Box::new(FuncCall::new(Some(c), n, a))),
	<n:Symbol> "(" <a:Comma<Arg>> ")" ";" => Statement::Call(Box::new(FuncCall::new(None, n, a))),
}

Ann: Annotation = {
	"@" <s:Symbol> "(" Comma<Arg> ")" => Annotation {name: s},
}

Symbol: String = {
	r"[a-zA-Z_]+"  => <>.to_string(),
}

List: Vec<String> = {
	"[" <Symbol+> "]"
}

Arg: Argument = {
	Symbol => Argument::Var(<>),
	List => Argument::List(<>),
	Quoted_String => Argument::Quote(<>),
}

Quoted_String: String = {
	r#""[^"]*""# => <>.to_string(),
}

// lexing precedence
match {
	r"\s*" => { },
	r"//[^\n\r]*[\n\r]*" => { },
} else {
	_
}
