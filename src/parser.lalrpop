use std::str::FromStr;
use crate::ast::{Policy, Declaration, Expression, Statement, TypeDecl, FuncDecl, Argument, Annotation};

grammar;

// http://lalrpop.github.io/lalrpop/tutorial/006_macros.html
Comma<T>: Vec<T> = {
	<mut v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			v.push(e);
			v
		}
	}
};

pub Policy: Box<Policy> = {
	Expr+ => Box::new(Policy::new(<>)),
}

pub Expr: Expression = {
	// TODO: Save annotation info in expression
	Ann <Expr>,
	<BaseExpr>
}

BaseExpr: Expression = {
	// TODO: other keywords beside virtual?
	"virtual"? <Decl> => Expression::Decl(<>),
	Stmt => Expression::Stmt(<>),
};

Decl: Declaration = {
	TypeDecl => Declaration::Type(<>),
	FuncDecl => Declaration::Func(<>),
}

TypeDecl: Box<TypeDecl> = {
	BuiltInType Symbol "{" Expr* "}" => Box::new(TypeDecl {}),
	BuiltInType Symbol "inherits" Comma<Symbol> "{" Expr* "}" => Box::new(TypeDecl {}),
}

BuiltInType = {
	"domain",
	"resource",
}

FuncDecl: Box<FuncDecl> = {
	// todo: commas
	"fn" Symbol "(" Comma<FuncDeclArg> ")" "{" Stmt+ "}" => Box::new(FuncDecl {}),
}

// TODO: Save the type
FuncDeclArg: String = {
	BuiltInType <Symbol>,
	Symbol <Symbol>,
	"[" BuiltInType "]" <Symbol>,
	"[" Symbol "]" <Symbol>,
}

Stmt: Statement = {
	Symbol "." Symbol "(" Comma<Arg> ")" ";" => Statement::Tmp,
	Symbol "(" Comma<Arg> ")" ";" => Statement::Tmp,
}

Ann: Box<Annotation> = {
	"@" Symbol "(" Comma<Arg> ")" => Box::new(Annotation {}),
}

Symbol: String = {
	r"[a-zA-Z_]+"  => <>.to_string(),
}

List: Vec<String> = {
	"[" <Symbol+> "]"
}

Arg: Argument = {
	Symbol => Argument::Var(<>),
	List => Argument::List(<>),
	Quoted_String => Argument::Quote(<>),
}

Quoted_String: String = {
	r#"".*""# => <>.to_string(),
}

// lexing precedence
match {
	r"\s*" => { },
	r"//[^\n\r]*[\n\r]*" => { },
} else {
	_
}
